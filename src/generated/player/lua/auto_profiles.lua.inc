// Generated from player/lua/auto_profiles.lua

"-- Note: anything global is accessible by profile condition expressions.\n"
"\n"
"local utils = require 'mp.utils'\n"
"local msg = require 'mp.msg'\n"
"\n"
"local profiles = {}\n"
"local watched_properties = {}       -- indexed by property name (used as a set)\n"
"local cached_properties = {}        -- property name -> last known raw value\n"
"local properties_to_profiles = {}   -- property name -> set of profiles using it\n"
"local have_dirty_profiles = false   -- at least one profile is marked dirty\n"
"local pending_hooks = {}            -- as set (keys only, meaningless values)\n"
"\n"
"-- Used during evaluation of the profile condition, and should contain the\n"
"-- profile the condition is evaluated for.\n"
"local current_profile = nil\n"
"\n"
"-- Cached set of all top-level mpv properities. Only used for extra validation.\n"
"local property_set = {}\n"
"for _, property in pairs(mp.get_property_native(\"property-list\")) do\n"
"    property_set[property] = true\n"
"end\n"
"\n"
"local function evaluate(profile)\n"
"    msg.verbose(\"Re-evaluating auto profile \" .. profile.name)\n"
"\n"
"    current_profile = profile\n"
"    local status, res = pcall(profile.cond)\n"
"    current_profile = nil\n"
"\n"
"    if not status then\n"
"        -- errors can be \"normal\", e.g. in case properties are unavailable\n"
"        msg.verbose(\"Profile condition error on evaluating: \" .. res)\n"
"        res = false\n"
"    end\n"
"    res = not not res\n"
"    if res ~= profile.status then\n"
"        if res == true then\n"
"            msg.info(\"Applying auto profile: \" .. profile.name)\n"
"            mp.commandv(\"apply-profile\", profile.name)\n"
"        elseif profile.status == true and profile.has_restore_opt then\n"
"            msg.info(\"Restoring profile: \" .. profile.name)\n"
"            mp.commandv(\"apply-profile\", profile.name, \"restore\")\n"
"        end\n"
"    end\n"
"    profile.status = res\n"
"    profile.dirty = false\n"
"end\n"
"\n"
"local function on_property_change(name, val)\n"
"    cached_properties[name] = val\n"
"    -- Mark all profiles reading this property as dirty, so they get re-evaluated\n"
"    -- the next time the script goes back to sleep.\n"
"    local dependent_profiles = properties_to_profiles[name]\n"
"    if dependent_profiles then\n"
"        for profile, _ in pairs(dependent_profiles) do\n"
"            assert(profile.cond) -- must be a profile table\n"
"            profile.dirty = true\n"
"            have_dirty_profiles = true\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function on_idle()\n"
"    -- When events and property notifications stop, re-evaluate all dirty profiles.\n"
"    if have_dirty_profiles then\n"
"        for _, profile in ipairs(profiles) do\n"
"            if profile.dirty then\n"
"                evaluate(profile)\n"
"            end\n"
"        end\n"
"    end\n"
"    have_dirty_profiles = false\n"
"    -- Release all hooks (the point was to wait until an idle event)\n"
"    while true do\n"
"        local h = next(pending_hooks)\n"
"        if not h then\n"
"            break\n"
"        end\n"
"        pending_hooks[h] = nil\n"
"        h:cont()\n"
"    end\n"
"end\n"
"\n"
"local function on_hook(h)\n"
"    h:defer()\n"
"    pending_hooks[h] = true\n"
"end\n"
"\n"
"function get(name, default)\n"
"    -- Normally, we use the cached value only\n"
"    if not watched_properties[name] then\n"
"        watched_properties[name] = true\n"
"        local res, err = mp.get_property_native(name)\n"
"        -- Property has to not exist and the toplevel of property in the name must also\n"
"        -- not have an existing match in the property set for this to be considered an error.\n"
"        -- This allows things like user-data/test to still work.\n"
"        if err == \"property not found\" and property_set[name:match(\"^([^/]+)\")] == nil then\n"
"            msg.error(\"Property '\" .. name .. \"' was not found.\")\n"
"            return default\n"
"        end\n"
"        cached_properties[name] = res\n"
"        mp.observe_property(name, \"native\", on_property_change)\n"
"    end\n"
"    -- The first time the property is read we need add it to the\n"
"    -- properties_to_profiles table, which will be used to mark the profile\n"
"    -- dirty if a property referenced by it changes.\n"
"    if current_profile then\n"
"        local map = properties_to_profiles[name]\n"
"        if not map then\n"
"            map = {}\n"
"            properties_to_profiles[name] = map\n"
"        end\n"
"        map[current_profile] = true\n"
"    end\n"
"    local val = cached_properties[name]\n"
"    if val == nil then\n"
"        val = default\n"
"    end\n"
"    return val\n"
"end\n"
"\n"
"local function magic_get(name)\n"
"    -- Lua identifiers can't contain \"-\", so in order to match with mpv\n"
"    -- property conventions, replace \"_\" to \"-\"\n"
"    name = string.gsub(name, \"_\", \"-\")\n"
"    return get(name, nil)\n"
"end\n"
"\n"
"local evil_magic = {}\n"
"setmetatable(evil_magic, {\n"
"    __index = function(table, key)\n"
"        -- interpret everything as property, unless it already exists as\n"
"        -- a non-nil global value\n"
"        local v = _G[key]\n"
"        if type(v) ~= \"nil\" then\n"
"            return v\n"
"        end\n"
"        return magic_get(key)\n"
"    end,\n"
"})\n"
"\n"
"p = {}\n"
"setmetatable(p, {\n"
"    __index = function(table, key)\n"
"        return magic_get(key)\n"
"    end,\n"
"})\n"
"\n"
"local function compile_cond(name, s)\n"
"    local code, chunkname = \"return \" .. s, \"profile \" .. name .. \" condition\"\n"
"    local chunk, err\n"
"    if setfenv then -- lua 5.1\n"
"        chunk, err = loadstring(code, chunkname)\n"
"        if chunk then\n"
"            setfenv(chunk, evil_magic)\n"
"        end\n"
"    else -- lua 5.2\n"
"        chunk, err = load(code, chunkname, \"t\", evil_magic)\n"
"    end\n"
"    if not chunk then\n"
"        msg.error(\"Profile '\" .. name .. \"' condition: \" .. err)\n"
"        chunk = function() return false end\n"
"    end\n"
"    return chunk\n"
"end\n"
"\n"
"local function load_profiles()\n"
"    for i, v in ipairs(mp.get_property_native(\"profile-list\")) do\n"
"        local cond = v[\"profile-cond\"]\n"
"        if cond and #cond > 0 then\n"
"            local profile = {\n"
"                name = v.name,\n"
"                cond = compile_cond(v.name, cond),\n"
"                properties = {},\n"
"                status = nil,\n"
"                dirty = true, -- need re-evaluate\n"
"                has_restore_opt = v[\"profile-restore\"] and v[\"profile-restore\"] ~= \"default\"\n"
"            }\n"
"            profiles[#profiles + 1] = profile\n"
"            have_dirty_profiles = true\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"load_profiles()\n"
"\n"
"if #profiles < 1 and mp.get_property(\"load-auto-profiles\") == \"auto\" then\n"
"    -- make it exit immediately\n"
"    _G.mp_event_loop = function() end\n"
"    return\n"
"end\n"
"\n"
"mp.register_idle(on_idle)\n"
"for _, name in ipairs({\"on_load\", \"on_preloaded\", \"on_before_start_file\"}) do\n"
"    mp.add_hook(name, 50, on_hook)\n"
"end\n"
"\n"
"on_idle() -- re-evaluate all profiles immediately\n"
