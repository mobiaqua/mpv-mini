// Generated from player/lua/ytdl_hook.lua

"local utils = require 'mp.utils'\n"
"local msg = require 'mp.msg'\n"
"local options = require 'mp.options'\n"
"\n"
"local o = {\n"
"    exclude = \"\",\n"
"    try_ytdl_first = false,\n"
"    use_manifests = false,\n"
"    all_formats = false,\n"
"    force_all_formats = true,\n"
"    ytdl_path = \"\",\n"
"}\n"
"\n"
"local ytdl = {\n"
"    path = \"\",\n"
"    paths_to_search = {\"yt-dlp\", \"yt-dlp_x86\", \"youtube-dl\"},\n"
"    searched = false,\n"
"    blacklisted = {}\n"
"}\n"
"\n"
"options.read_options(o, nil, function()\n"
"    ytdl.blacklisted = {} -- reparse o.exclude next time\n"
"    ytdl.searched = false\n"
"end)\n"
"\n"
"local chapter_list = {}\n"
"\n"
"function Set (t)\n"
"    local set = {}\n"
"    for _, v in pairs(t) do set[v] = true end\n"
"    return set\n"
"end\n"
"\n"
"-- \077: surrogate (keep in mind that there is no lazy evaluation)\n"
"function iif(cond, if_true, if_false)\n"
"    if cond then\n"
"        return if_true\n"
"    end\n"
"    return if_false\n"
"end\n"
"\n"
"-- youtube-dl JSON name to mpv tag name\n"
"local tag_list = {\n"
"    [\"uploader\"]        = \"uploader\",\n"
"    [\"channel_url\"]     = \"channel_url\",\n"
"    -- these titles tend to be a bit too long, so hide them on the terminal\n"
"    -- (default --display-tags does not include this name)\n"
"    [\"description\"]     = \"ytdl_description\",\n"
"    -- \"title\" is handled by force-media-title\n"
"    -- tags don't work with all_formats=yes\n"
"}\n"
"\n"
"local safe_protos = Set {\n"
"    \"http\", \"https\", \"ftp\", \"ftps\",\n"
"    \"rtmp\", \"rtmps\", \"rtmpe\", \"rtmpt\", \"rtmpts\", \"rtmpte\",\n"
"    \"data\"\n"
"}\n"
"\n"
"-- For some sites, youtube-dl returns the audio codec (\077) only in the \"ext\" field.\n"
"local ext_map = {\n"
"    [\"mp3\"]         = \"mp3\",\n"
"    [\"opus\"]        = \"opus\",\n"
"}\n"
"\n"
"local codec_map = {\n"
"    -- src pattern  = mpv codec\n"
"    [\"vtt\"]         = \"webvtt\",\n"
"    [\"opus\"]        = \"opus\",\n"
"    [\"vp9\"]         = \"vp9\",\n"
"    [\"avc1%..*\"]    = \"h264\",\n"
"    [\"av01%..*\"]    = \"av1\",\n"
"    [\"mp4a%..*\"]    = \"aac\",\n"
"}\n"
"\n"
"-- Codec name as reported by youtube-dl mapped to mpv internal codec names.\n"
"-- Fun fact: mpv will not really use the codec, but will still try to initialize\n"
"-- the codec on track selection (just to scrap it), meaning it's only a hint,\n"
"-- but one that may make initialization fail. On the other hand, if the codec\n"
"-- is valid but completely different from the actual media, nothing bad happens.\n"
"local function map_codec_to_mpv(codec)\n"
"    if codec == nil then\n"
"        return nil\n"
"    end\n"
"    for k, v in pairs(codec_map) do\n"
"        local s, e = codec:find(k)\n"
"        if s == 1 and e == #codec then\n"
"            return v\n"
"        end\n"
"    end\n"
"    return nil\n"
"end\n"
"\n"
"local function platform_is_windows()\n"
"    return mp.get_property_native(\"platform\") == \"windows\"\n"
"end\n"
"\n"
"local function exec(args)\n"
"    msg.debug(\"Running: \" .. table.concat(args, \" \"))\n"
"\n"
"    return mp.command_native({\n"
"        name = \"subprocess\",\n"
"        args = args,\n"
"        capture_stdout = true,\n"
"        capture_stderr = true,\n"
"    })\n"
"end\n"
"\n"
"-- return true if it was explicitly set on the command line\n"
"local function option_was_set(name)\n"
"    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-from-commandline\",\n"
"                                false)\n"
"end\n"
"\n"
"-- return true if the option was set locally\n"
"local function option_was_set_locally(name)\n"
"    return mp.get_property_bool(\"option-info/\" ..name.. \"/set-locally\", false)\n"
"end\n"
"\n"
"-- youtube-dl may set special http headers for some sites (user-agent, cookies)\n"
"local function set_http_headers(http_headers)\n"
"    if not http_headers then\n"
"        return\n"
"    end\n"
"    local headers = {}\n"
"    local useragent = http_headers[\"User-Agent\"]\n"
"    if useragent and not option_was_set(\"user-agent\") then\n"
"        mp.set_property(\"file-local-options/user-agent\", useragent)\n"
"    end\n"
"    local additional_fields = {\"Cookie\", \"Referer\", \"X-Forwarded-For\"}\n"
"    for idx, item in pairs(additional_fields) do\n"
"        local field_value = http_headers[item]\n"
"        if field_value then\n"
"            headers[#headers + 1] = item .. \": \" .. field_value\n"
"        end\n"
"    end\n"
"    if #headers > 0 and not option_was_set(\"http-header-fields\") then\n"
"        mp.set_property_native(\"file-local-options/http-header-fields\", headers)\n"
"    end\n"
"end\n"
"\n"
"local function append_libav_opt(props, name, value)\n"
"    if not props then\n"
"        props = {}\n"
"    end\n"
"\n"
"    if name and value and not props[name] then\n"
"        props[name] = value\n"
"    end\n"
"\n"
"    return props\n"
"end\n"
"\n"
"local function edl_escape(url)\n"
"    return \"%\" .. string.len(url) .. \"%\" .. url\n"
"end\n"
"\n"
"local function url_is_safe(url)\n"
"    local proto = type(url) == \"string\" and url:match(\"^(%a[%w+.-]*):\") or nil\n"
"    local safe = proto and safe_protos[proto]\n"
"    if not safe then\n"
"        msg.error((\"Ignoring potentially unsafe url: '%s'\"):format(url))\n"
"    end\n"
"    return safe\n"
"end\n"
"\n"
"local function time_to_secs(time_string)\n"
"    local ret\n"
"\n"
"    local a, b, c = time_string:match(\"(%d+):(%d%d\077):(%d%d)\")\n"
"    if a ~= nil then\n"
"        ret = (a*3600 + b*60 + c)\n"
"    else\n"
"        a, b = time_string:match(\"(%d%d\077):(%d%d)\")\n"
"        if a ~= nil then\n"
"            ret = (a*60 + b)\n"
"        end\n"
"    end\n"
"\n"
"    return ret\n"
"end\n"
"\n"
"local function extract_chapters(data, video_length)\n"
"    local ret = {}\n"
"\n"
"    for line in data:gmatch(\"[^\\r\\n]+\") do\n"
"        local time = time_to_secs(line)\n"
"        if time and (time < video_length) then\n"
"            table.insert(ret, {time = time, title = line})\n"
"        end\n"
"    end\n"
"    table.sort(ret, function(a, b) return a.time < b.time end)\n"
"    return ret\n"
"end\n"
"\n"
"local function is_blacklisted(url)\n"
"    if o.exclude == \"\" then return false end\n"
"    if #ytdl.blacklisted == 0 then\n"
"        for match in o.exclude:gmatch('%|\077([^|]+)') do\n"
"            ytdl.blacklisted[#ytdl.blacklisted + 1] = match\n"
"        end\n"
"    end\n"
"    if #ytdl.blacklisted > 0 then\n"
"        url = url:match('https\077://(.+)')\n"
"        for _, exclude in ipairs(ytdl.blacklisted) do\n"
"            if url:match(exclude) then\n"
"                msg.verbose('URL matches excluded substring. Skipping.')\n"
"                return true\n"
"            end\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"\n"
"local function parse_yt_playlist(url, json)\n"
"    -- return 0-based index to use with --playlist-start\n"
"\n"
"    if not json.extractor or\n"
"       (json.extractor ~= \"youtube:tab\" and\n"
"        json.extractor ~= \"youtube:playlist\") then\n"
"        return nil\n"
"    end\n"
"\n"
"    local query = url:match(\"%\077.+\")\n"
"    if not query then return nil end\n"
"\n"
"    local args = {}\n"
"    for arg, param in query:gmatch(\"(%a+)=([^&\077]+)\") do\n"
"        if arg and param then\n"
"            args[arg] = param\n"
"        end\n"
"    end\n"
"\n"
"    local maybe_idx = tonumber(args[\"index\"])\n"
"\n"
"    -- if index matches v param it's probably the requested item\n"
"    if maybe_idx and #json.entries >= maybe_idx and\n"
"        json.entries[maybe_idx].id == args[\"v\"] then\n"
"        msg.debug(\"index matches requested video\")\n"
"        return maybe_idx - 1\n"
"    end\n"
"\n"
"    -- if there's no index or it doesn't match, look for video\n"
"    for i = 1, #json.entries do\n"
"        if json.entries[i].id == args[\"v\"] then\n"
"            msg.debug(\"found requested video in index \" .. (i - 1))\n"
"            return i - 1\n"
"        end\n"
"    end\n"
"\n"
"    msg.debug(\"requested video not found in playlist\")\n"
"    -- if item isn't on the playlist, give up\n"
"    return nil\n"
"end\n"
"\n"
"local function make_absolute_url(base_url, url)\n"
"    if url:find(\"https\077://\") == 1 then return url end\n"
"\n"
"    local proto, domain, rest =\n"
"        base_url:match(\"(https\077://)([^/]+/)(.*)/\077\")\n"
"    local segs = {}\n"
"    rest:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n"
"    url:gsub(\"([^/]+)\", function(c) table.insert(segs, c) end)\n"
"    local resolved_url = {}\n"
"    for i, v in ipairs(segs) do\n"
"        if v == \"..\" then\n"
"            table.remove(resolved_url)\n"
"        elseif v ~= \".\" then\n"
"            table.insert(resolved_url, v)\n"
"        end\n"
"    end\n"
"    return proto .. domain ..\n"
"        table.concat(resolved_url, \"/\")\n"
"end\n"
"\n"
"local function join_url(base_url, fragment)\n"
"    local res = \"\"\n"
"    if base_url and fragment.path then\n"
"        res = make_absolute_url(base_url, fragment.path)\n"
"    elseif fragment.url then\n"
"        res = fragment.url\n"
"    end\n"
"    return res\n"
"end\n"
"\n"
"local function edl_track_joined(fragments, protocol, is_live, base)\n"
"    if not (type(fragments) == \"table\") or not fragments[1] then\n"
"        msg.debug(\"No fragments to join into EDL\")\n"
"        return nil\n"
"    end\n"
"\n"
"    local edl = \"edl://\"\n"
"    local offset = 1\n"
"    local parts = {}\n"
"\n"
"    if (protocol == \"http_dash_segments\") and not is_live then\n"
"        msg.debug(\"Using dash\")\n"
"        local args = \"\"\n"
"\n"
"        -- assume MP4 DASH initialization segment\n"
"        if not fragments[1].duration and #fragments > 1 then\n"
"            msg.debug(\"Using init segment\")\n"
"            args = args .. \",init=\" .. edl_escape(join_url(base, fragments[1]))\n"
"            offset = 2\n"
"        end\n"
"\n"
"        table.insert(parts, \"!mp4_dash\" .. args)\n"
"\n"
"        -- Check remaining fragments for duration;\n"
"        -- if not available in all, give up.\n"
"        for i = offset, #fragments do\n"
"            if not fragments[i].duration then\n"
"                msg.verbose(\"EDL doesn't support fragments \" ..\n"
"                         \"without duration with MP4 DASH\")\n"
"                return nil\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    for i = offset, #fragments do\n"
"        local fragment = fragments[i]\n"
"        if not url_is_safe(join_url(base, fragment)) then\n"
"            return nil\n"
"        end\n"
"        table.insert(parts, edl_escape(join_url(base, fragment)))\n"
"        if fragment.duration then\n"
"            parts[#parts] =\n"
"                parts[#parts] .. \",length=\"..fragment.duration\n"
"        end\n"
"    end\n"
"    return edl .. table.concat(parts, \";\") .. \";\"\n"
"end\n"
"\n"
"local function has_native_dash_demuxer()\n"
"    local demuxers = mp.get_property_native(\"demuxer-lavf-list\", {})\n"
"    for _, v in ipairs(demuxers) do\n"
"        if v == \"dash\" then\n"
"            return true\n"
"        end\n"
"    end\n"
"    return false\n"
"end\n"
"\n"
"local function valid_manifest(json)\n"
"    local reqfmt = json[\"requested_formats\"] and json[\"requested_formats\"][1] or {}\n"
"    if not reqfmt[\"manifest_url\"] and not json[\"manifest_url\"] then\n"
"        return false\n"
"    end\n"
"    local proto = reqfmt[\"protocol\"] or json[\"protocol\"] or \"\"\n"
"    return (proto == \"http_dash_segments\" and has_native_dash_demuxer()) or\n"
"        proto:find(\"^m3u8\")\n"
"end\n"
"\n"
"local function as_integer(v, def)\n"
"    def = def or 0\n"
"    local num = math.floor(tonumber(v) or def)\n"
"    if num > -math.huge and num < math.huge then\n"
"        return num\n"
"    end\n"
"    return def\n"
"end\n"
"\n"
"local function tags_to_edl(json)\n"
"    local tags = {}\n"
"    for json_name, mp_name in pairs(tag_list) do\n"
"        local v = json[json_name]\n"
"        if v then\n"
"            tags[#tags + 1] = mp_name .. \"=\" .. edl_escape(tostring(v))\n"
"        end\n"
"    end\n"
"    if #tags == 0 then\n"
"        return nil\n"
"    end\n"
"    return \"!global_tags,\" .. table.concat(tags, \",\")\n"
"end\n"
"\n"
"-- Convert a format list from youtube-dl to an EDL URL, or plain URL.\n"
"--  json: full json blob by youtube-dl\n"
"--  formats: format list by youtube-dl\n"
"--  use_all_formats: if=true, then formats is the full format list, and the\n"
"--                   function will attempt to return them as delay-loaded tracks\n"
"-- See res table initialization in the function for result type.\n"
"local function formats_to_edl(json, formats, use_all_formats)\n"
"    local res = {\n"
"        -- the media URL, which may be EDL\n"
"        url = nil,\n"
"        -- for use_all_formats=true: whether any muxed formats are present, and\n"
"        -- at the same time the separate EDL parts don't have both audio/video\n"
"        muxed_needed = false,\n"
"    }\n"
"\n"
"    local default_formats = {}\n"
"    local requested_formats = json[\"requested_formats\"] or json[\"requested_downloads\"]\n"
"    if use_all_formats and requested_formats then\n"
"        for _, track in ipairs(requested_formats) do\n"
"            local id = track[\"format_id\"]\n"
"            if id then\n"
"                default_formats[id] = true\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    local duration = as_integer(json[\"duration\"])\n"
"    local single_url = nil\n"
"    local streams = {}\n"
"\n"
"    local tbr_only = true\n"
"    for index, track in ipairs(formats) do\n"
"        tbr_only = tbr_only and track[\"tbr\"] and\n"
"                   (not track[\"abr\"]) and (not track[\"vbr\"])\n"
"    end\n"
"\n"
"    local has_requested_video = false\n"
"    local has_requested_audio = false\n"
"    -- Web players with quality selection always show the highest quality\n"
"    -- option at the top. Since tracks are usually listed with the first\n"
"    -- track at the top, that should also be the highest quality track.\n"
"    -- yt-dlp/youtube-dl sorts it's formats from worst to best.\n"
"    -- Iterate in reverse to get best track first.\n"
"    for index = #formats, 1, -1 do\n"
"        local track = formats[index]\n"
"        local edl_track = nil\n"
"        edl_track = edl_track_joined(track.fragments,\n"
"            track.protocol, json.is_live,\n"
"            track.fragment_base_url)\n"
"        if not edl_track and not url_is_safe(track.url) then\n"
"            msg.error(\"No safe URL or supported fragmented stream available\")\n"
"            return nil\n"
"        end\n"
"\n"
"        local is_default = default_formats[track[\"format_id\"]]\n"
"        local tracks = {}\n"
"        -- \"none\" means it is not a video\n"
"        -- nil means it is unknown\n"
"        if (o.force_all_formats or track.vcodec) and track.vcodec ~= \"none\" then\n"
"            tracks[#tracks + 1] = {\n"
"                media_type = \"video\",\n"
"                codec = map_codec_to_mpv(track.vcodec),\n"
"            }\n"
"            if is_default then\n"
"                has_requested_video = true\n"
"            end\n"
"        end\n"
"        if (o.force_all_formats or track.acodec) and track.acodec ~= \"none\" then\n"
"            tracks[#tracks + 1] = {\n"
"                media_type = \"audio\",\n"
"                codec = map_codec_to_mpv(track.acodec) or\n"
"                        ext_map[track.ext],\n"
"            }\n"
"            if is_default then\n"
"                has_requested_audio = true\n"
"            end\n"
"        end\n"
"\n"
"        local url = edl_track or track.url\n"
"        local hdr = {\"!new_stream\", \"!no_clip\", \"!no_chapters\"}\n"
"        local skip = #tracks == 0\n"
"        local params = \"\"\n"
"\n"
"        if use_all_formats then\n"
"            for _, sub in ipairs(tracks) do\n"
"                -- A single track that is either audio or video. Delay load it.\n"
"                local props = \"\"\n"
"                if sub.media_type == \"video\" then\n"
"                    props = props .. \",w=\" .. as_integer(track.width)\n"
"                                  .. \",h=\" .. as_integer(track.height)\n"
"                                  .. \",fps=\" .. as_integer(track.fps)\n"
"                elseif sub.media_type == \"audio\" then\n"
"                    props = props .. \",samplerate=\" .. as_integer(track.asr)\n"
"                end\n"
"                hdr[#hdr + 1] = \"!delay_open,media_type=\" .. sub.media_type ..\n"
"                    \",codec=\" .. (sub.codec or \"null\") .. props\n"
"\n"
"                -- Add bitrate information etc. for better user selection.\n"
"                local byterate = 0\n"
"                local rates = {\"tbr\", \"vbr\", \"abr\"}\n"
"                if #tracks > 1 then\n"
"                    rates = {({video = \"vbr\", audio = \"abr\"})[sub.media_type]}\n"
"                end\n"
"                if tbr_only then\n"
"                    rates = {\"tbr\"}\n"
"                end\n"
"                for _, f in ipairs(rates) do\n"
"                    local br = as_integer(track[f])\n"
"                    if br > 0 then\n"
"                        byterate = math.floor(br * 1000 / 8)\n"
"                        break\n"
"                    end\n"
"                end\n"
"                local title = track.format or track.format_note or \"\"\n"
"                if #tracks > 1 then\n"
"                    if #title > 0 then\n"
"                        title = title .. \" \"\n"
"                    end\n"
"                    title = title .. \"muxed-\" .. index\n"
"                end\n"
"                local flags = {}\n"
"                if is_default then\n"
"                    flags[#flags + 1] = \"default\"\n"
"                end\n"
"                hdr[#hdr + 1] = \"!track_meta,title=\" ..\n"
"                    edl_escape(title) .. \",byterate=\" .. byterate ..\n"
"                    iif(#flags > 0, \",flags=\" .. table.concat(flags, \"+\"), \"\")\n"
"            end\n"
"\n"
"            if duration > 0 then\n"
"                params = params .. \",length=\" .. duration\n"
"            end\n"
"        end\n"
"\n"
"        if not skip then\n"
"            hdr[#hdr + 1] = edl_escape(url) .. params\n"
"\n"
"            streams[#streams + 1] = table.concat(hdr, \";\")\n"
"            -- In case there is only 1 of these streams.\n"
"            -- Note: assumes it has no important EDL headers\n"
"            single_url = url\n"
"        end\n"
"    end\n"
"\n"
"    -- Merge all tracks into a single virtual file, but avoid EDL if it's\n"
"    -- only a single track (i.e. redundant).\n"
"    if #streams == 1 and single_url then\n"
"        res.url = single_url\n"
"    elseif #streams > 0 then\n"
"        local tags = tags_to_edl(json)\n"
"        if tags then\n"
"            -- not a stream; just for the sake of concatenating the EDL string\n"
"            streams[#streams + 1] = tags\n"
"        end\n"
"        res.url = \"edl://\" .. table.concat(streams, \";\")\n"
"    else\n"
"        return nil\n"
"    end\n"
"\n"
"    if has_requested_audio ~= has_requested_video then\n"
"        local not_req_prop = has_requested_video and \"aid\" or \"vid\"\n"
"        if mp.get_property(not_req_prop) == \"auto\" then\n"
"            mp.set_property(\"file-local-options/\" .. not_req_prop, \"no\")\n"
"        end\n"
"    end\n"
"\n"
"    return res\n"
"end\n"
"\n"
"local function add_single_video(json)\n"
"    local streamurl = \"\"\n"
"    local format_info = \"\"\n"
"    local max_bitrate = 0\n"
"    local requested_formats = json[\"requested_formats\"] or json[\"requested_downloads\"]\n"
"    local all_formats = json[\"formats\"]\n"
"    local has_requested_formats = requested_formats and #requested_formats > 0\n"
"    local http_headers = has_requested_formats\n"
"                         and requested_formats[1].http_headers\n"
"                         or json.http_headers\n"
"\n"
"    if o.use_manifests and valid_manifest(json) then\n"
"        -- prefer manifest_url if present\n"
"        format_info = \"manifest\"\n"
"\n"
"        local mpd_url = requested_formats and\n"
"            requested_formats[1][\"manifest_url\"] or json[\"manifest_url\"]\n"
"        if not mpd_url then\n"
"            msg.error(\"No manifest URL found in JSON data.\")\n"
"            return\n"
"        elseif not url_is_safe(mpd_url) then\n"
"            return\n"
"        end\n"
"\n"
"        streamurl = mpd_url\n"
"\n"
"        if requested_formats then\n"
"            for _, track in pairs(requested_formats) do\n"
"                max_bitrate = (track.tbr and track.tbr > max_bitrate) and\n"
"                    track.tbr or max_bitrate\n"
"            end\n"
"        elseif json.tbr then\n"
"            max_bitrate = json.tbr > max_bitrate and json.tbr or max_bitrate\n"
"        end\n"
"    end\n"
"\n"
"    if streamurl == \"\"  then\n"
"        -- possibly DASH/split tracks\n"
"        local res = nil\n"
"\n"
"        -- Not having requested_formats usually hints to HLS master playlist\n"
"        -- usage, which we don't want to split off, at least not yet.\n"
"        if (all_formats and o.all_formats) and\n"
"           (has_requested_formats or o.force_all_formats)\n"
"        then\n"
"            format_info = \"all_formats (separate)\"\n"
"            res = formats_to_edl(json, all_formats, true)\n"
"            -- Note: since we don't delay-load muxed streams, use normal stream\n"
"            -- selection if we have to use muxed streams.\n"
"            if res and res.muxed_needed then\n"
"                res = nil\n"
"            end\n"
"        end\n"
"\n"
"        if (not res) and has_requested_formats then\n"
"            format_info = \"youtube-dl (separate)\"\n"
"            res = formats_to_edl(json, requested_formats, false)\n"
"        end\n"
"\n"
"        if res then\n"
"            streamurl = res.url\n"
"        end\n"
"    end\n"
"\n"
"    if streamurl == \"\" and json.url then\n"
"        format_info = \"youtube-dl (single)\"\n"
"        local edl_track = nil\n"
"        edl_track = edl_track_joined(json.fragments, json.protocol,\n"
"            json.is_live, json.fragment_base_url)\n"
"\n"
"        if not edl_track and not url_is_safe(json.url) then\n"
"            return\n"
"        end\n"
"        -- normal video or single track\n"
"        streamurl = edl_track or json.url\n"
"    end\n"
"\n"
"    if streamurl == \"\" then\n"
"        msg.error(\"No URL found in JSON data.\")\n"
"        return\n"
"    end\n"
"\n"
"    set_http_headers(http_headers)\n"
"\n"
"    msg.verbose(\"format selection: \" .. format_info)\n"
"    msg.debug(\"streamurl: \" .. streamurl)\n"
"\n"
"    mp.set_property(\"stream-open-filename\", streamurl:gsub(\"^data:\", \"data://\", 1))\n"
"\n"
"    if mp.get_property(\"force-media-title\", \"\") == \"\" then\n"
"        mp.set_property(\"file-local-options/force-media-title\", json.title)\n"
"    end\n"
"\n"
"    -- set hls-bitrate for dash track selection\n"
"    if max_bitrate > 0 and\n"
"        not option_was_set(\"hls-bitrate\") and\n"
"        not option_was_set_locally(\"hls-bitrate\") then\n"
"        mp.set_property_native('file-local-options/hls-bitrate', max_bitrate*1000)\n"
"    end\n"
"\n"
"    -- add subtitles\n"
"    if not (json.requested_subtitles == nil) then\n"
"        local subs = {}\n"
"        for lang, info in pairs(json.requested_subtitles) do\n"
"            subs[#subs + 1] = {lang = lang or \"-\", info = info}\n"
"        end\n"
"        table.sort(subs, function(a, b) return a.lang < b.lang end)\n"
"        for _, e in ipairs(subs) do\n"
"            local lang, sub_info = e.lang, e.info\n"
"            msg.verbose(\"adding subtitle [\"..lang..\"]\")\n"
"\n"
"            local sub = nil\n"
"\n"
"            if not (sub_info.data == nil) then\n"
"                sub = \"memory://\"..sub_info.data\n"
"            elseif not (sub_info.url == nil) and\n"
"                url_is_safe(sub_info.url) then\n"
"                sub = sub_info.url\n"
"            end\n"
"\n"
"            if not (sub == nil) then\n"
"                local edl = \"edl://!no_clip;!delay_open,media_type=sub\"\n"
"                local codec = map_codec_to_mpv(sub_info.ext)\n"
"                if codec then\n"
"                    edl = edl .. \",codec=\" .. codec\n"
"                end\n"
"                edl = edl .. \";\" .. edl_escape(sub)\n"
"                local title = sub_info.name or sub_info.ext\n"
"                mp.commandv(\"sub-add\", edl, \"auto\", title, lang)\n"
"            else\n"
"                msg.verbose(\"No subtitle data/url for [\"..lang..\"]\")\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"    -- add chapters\n"
"    if json.chapters then\n"
"        msg.debug(\"Adding pre-parsed chapters\")\n"
"        for i = 1, #json.chapters do\n"
"            local chapter = json.chapters[i]\n"
"            local title = chapter.title or \"\"\n"
"            if title == \"\" then\n"
"                title = string.format('Chapter %02d', i)\n"
"            end\n"
"            table.insert(chapter_list, {time=chapter.start_time, title=title})\n"
"        end\n"
"    elseif not (json.description == nil) and not (json.duration == nil) then\n"
"        chapter_list = extract_chapters(json.description, json.duration)\n"
"    end\n"
"\n"
"    -- set start time\n"
"    if (json.start_time or json.section_start) and\n"
"        not option_was_set(\"start\") and\n"
"        not option_was_set_locally(\"start\") then\n"
"        local start_time = json.start_time or json.section_start\n"
"        msg.debug(\"Setting start to: \" .. start_time .. \" secs\")\n"
"        mp.set_property(\"file-local-options/start\", start_time)\n"
"    end\n"
"\n"
"    -- set end time\n"
"    if (json.end_time or json.section_end) and\n"
"        not option_was_set(\"end\") and\n"
"        not option_was_set_locally(\"end\") then\n"
"        local end_time = json.end_time or json.section_end\n"
"        msg.debug(\"Setting end to: \" .. end_time .. \" secs\")\n"
"        mp.set_property(\"file-local-options/end\", end_time)\n"
"    end\n"
"\n"
"    -- set aspect ratio for anamorphic video\n"
"    if not (json.stretched_ratio == nil) and\n"
"        not option_was_set(\"video-aspect-override\") then\n"
"        mp.set_property('file-local-options/video-aspect-override', json.stretched_ratio)\n"
"    end\n"
"\n"
"    local stream_opts = mp.get_property_native(\"file-local-options/stream-lavf-o\", {})\n"
"\n"
"    -- for rtmp\n"
"    if (json.protocol == \"rtmp\") then\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_tcurl\", streamurl)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_pageurl\", json.page_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_playpath\", json.play_path)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_swfverify\", json.player_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_swfurl\", json.player_url)\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"rtmp_app\", json.app)\n"
"    end\n"
"\n"
"    if json.proxy and json.proxy ~= \"\" then\n"
"        stream_opts = append_libav_opt(stream_opts,\n"
"            \"http_proxy\", json.proxy)\n"
"    end\n"
"\n"
"    mp.set_property_native(\"file-local-options/stream-lavf-o\", stream_opts)\n"
"end\n"
"\n"
"local function check_version(ytdl_path)\n"
"    local command = {\n"
"        name = \"subprocess\",\n"
"        capture_stdout = true,\n"
"        args = {ytdl_path, \"--version\"}\n"
"    }\n"
"    local version_string = mp.command_native(command).stdout\n"
"    local year, month, day = string.match(version_string, \"(%d+).(%d+).(%d+)\")\n"
"\n"
"    -- sanity check\n"
"    if (tonumber(year) < 2000) or (tonumber(month) > 12) or\n"
"        (tonumber(day) > 31) then\n"
"        return\n"
"    end\n"
"    local version_ts = os.time{year=year, month=month, day=day}\n"
"    if (os.difftime(os.time(), version_ts) > 60*60*24*90) then\n"
"        msg.warn(\"It appears that your youtube-dl version is severely out of date.\")\n"
"    end\n"
"end\n"
"\n"
"function run_ytdl_hook(url)\n"
"    local start_time = os.clock()\n"
"\n"
"    -- strip ytdl://\n"
"    if (url:find(\"ytdl://\") == 1) then\n"
"        url = url:sub(8)\n"
"    end\n"
"\n"
"    local format = mp.get_property(\"options/ytdl-format\")\n"
"    local raw_options = mp.get_property_native(\"options/ytdl-raw-options\")\n"
"    local allsubs = true\n"
"    local proxy = nil\n"
"    local use_playlist = false\n"
"\n"
"    local command = {\n"
"        ytdl.path, \"--no-warnings\", \"-J\", \"--flat-playlist\",\n"
"        \"--sub-format\", \"ass/srt/best\"\n"
"    }\n"
"\n"
"    -- Checks if video option is \"no\", change format accordingly,\n"
"    -- but only if user didn't explicitly set one\n"
"    if (mp.get_property(\"options/vid\") == \"no\") and (#format == 0) then\n"
"        format = \"bestaudio/best\"\n"
"        msg.verbose(\"Video disabled. Only using audio\")\n"
"    end\n"
"\n"
"    if (format == \"\") then\n"
"        format = \"bestvideo+bestaudio/best\"\n"
"    end\n"
"\n"
"    if format ~= \"ytdl\" then\n"
"        table.insert(command, \"--format\")\n"
"        table.insert(command, format)\n"
"    end\n"
"\n"
"    for param, arg in pairs(raw_options) do\n"
"        table.insert(command, \"--\" .. param)\n"
"        if (arg ~= \"\") then\n"
"            table.insert(command, arg)\n"
"        end\n"
"        if (param == \"sub-lang\" or param == \"sub-langs\" or param == \"srt-lang\") and (arg ~= \"\") then\n"
"            allsubs = false\n"
"        elseif (param == \"proxy\") and (arg ~= \"\") then\n"
"            proxy = arg\n"
"        elseif (param == \"yes-playlist\") then\n"
"            use_playlist = true\n"
"        end\n"
"    end\n"
"\n"
"    if (allsubs == true) then\n"
"        table.insert(command, \"--all-subs\")\n"
"    end\n"
"    if not use_playlist then\n"
"        table.insert(command, \"--no-playlist\")\n"
"    end\n"
"    table.insert(command, \"--\")\n"
"    table.insert(command, url)\n"
"\n"
"    local result\n"
"    if ytdl.searched then\n"
"        result = exec(command)\n"
"    else\n"
"        local separator = platform_is_windows() and \";\" or \":\"\n"
"        if o.ytdl_path:match(\"[^\" .. separator .. \"]\") then\n"
"            ytdl.paths_to_search = {}\n"
"            for path in o.ytdl_path:gmatch(\"[^\" .. separator .. \"]+\") do\n"
"                table.insert(ytdl.paths_to_search, path)\n"
"            end\n"
"        end\n"
"\n"
"        for _, path in pairs(ytdl.paths_to_search) do\n"
"            -- search for youtube-dl in mpv's config dir\n"
"            local exesuf = platform_is_windows() and \".exe\" or \"\"\n"
"            local ytdl_cmd = mp.find_config_file(path .. exesuf)\n"
"            if ytdl_cmd then\n"
"                msg.verbose(\"Found youtube-dl at: \" .. ytdl_cmd)\n"
"                ytdl.path = ytdl_cmd\n"
"                command[1] = ytdl.path\n"
"                result = exec(command)\n"
"                break\n"
"            else\n"
"                msg.verbose(\"No youtube-dl found with path \" .. path .. exesuf .. \" in config directories\")\n"
"                command[1] = path\n"
"                result = exec(command)\n"
"                if result.error_string == \"init\" then\n"
"                    msg.verbose(\"youtube-dl with path \" .. path .. exesuf .. \" not found in PATH or not enough permissions\")\n"
"                else\n"
"                    msg.verbose(\"Found youtube-dl with path \" .. path .. exesuf .. \" in PATH\")\n"
"                    ytdl.path = path\n"
"                    break\n"
"                end\n"
"            end\n"
"        end\n"
"\n"
"        ytdl.searched = true\n"
"    end\n"
"\n"
"    if result.killed_by_us then\n"
"        return\n"
"    end\n"
"\n"
"    local json = result.stdout\n"
"    local parse_err = nil\n"
"\n"
"    if result.status ~= 0 or json == \"\" then\n"
"        json = nil\n"
"    elseif json then\n"
"        json, parse_err = utils.parse_json(json)\n"
"    end\n"
"\n"
"    if (json == nil) then\n"
"        msg.verbose(\"status:\", result.status)\n"
"        msg.verbose(\"reason:\", result.error_string)\n"
"        msg.verbose(\"stdout:\", result.stdout)\n"
"        msg.verbose(\"stderr:\", result.stderr)\n"
"\n"
"        -- trim our stderr to avoid spurious newlines\n"
"        ytdl_err = result.stderr:gsub(\"^%s*(.-)%s*\044\", \"%1\")\n"
"        msg.error(ytdl_err)\n"
"        local err = \"youtube-dl failed: \"\n"
"        if result.error_string and result.error_string == \"init\" then\n"
"            err = err .. \"not found or not enough permissions\"\n"
"        elseif parse_err then\n"
"            err = err .. \"failed to parse JSON data: \" .. parse_err\n"
"        else\n"
"            err = err .. \"unexpected error occurred\"\n"
"        end\n"
"        msg.error(err)\n"
"        if parse_err or string.find(ytdl_err, \"yt%-dl%.org/bug\") then\n"
"            check_version(ytdl.path)\n"
"        end\n"
"        return\n"
"    end\n"
"\n"
"    msg.verbose(\"youtube-dl succeeded!\")\n"
"    msg.debug('ytdl parsing took '..os.clock()-start_time..' seconds')\n"
"\n"
"    json[\"proxy\"] = json[\"proxy\"] or proxy\n"
"\n"
"    -- what did we get\077\n"
"    if json[\"direct\"] then\n"
"        -- direct URL, nothing to do\n"
"        msg.verbose(\"Got direct URL\")\n"
"        return\n"
"    elseif (json[\"_type\"] == \"playlist\")\n"
"        or (json[\"_type\"] == \"multi_video\") then\n"
"        -- a playlist\n"
"\n"
"        if (#json.entries == 0) then\n"
"            msg.warn(\"Got empty playlist, nothing to play.\")\n"
"            return\n"
"        end\n"
"\n"
"        local self_redirecting_url =\n"
"            json.entries[1][\"_type\"] ~= \"url_transparent\" and\n"
"            json.entries[1][\"webpage_url\"] and\n"
"            json.entries[1][\"webpage_url\"] == json[\"webpage_url\"]\n"
"\n"
"\n"
"        -- some funky guessing to detect multi-arc videos\n"
"        if self_redirecting_url and #json.entries > 1\n"
"            and json.entries[1].protocol == \"m3u8_native\"\n"
"            and json.entries[1].url then\n"
"            msg.verbose(\"multi-arc video detected, building EDL\")\n"
"\n"
"            local playlist = edl_track_joined(json.entries)\n"
"\n"
"            msg.debug(\"EDL: \" .. playlist)\n"
"\n"
"            if not playlist then\n"
"                return\n"
"            end\n"
"\n"
"            -- can't change the http headers for each entry, so use the 1st\n"
"            set_http_headers(json.entries[1].http_headers)\n"
"\n"
"            mp.set_property(\"stream-open-filename\", playlist)\n"
"            if json.title and mp.get_property(\"force-media-title\", \"\") == \"\" then\n"
"                mp.set_property(\"file-local-options/force-media-title\",\n"
"                    json.title)\n"
"            end\n"
"\n"
"            -- there might not be subs for the first segment\n"
"            local entry_wsubs = nil\n"
"            for i, entry in pairs(json.entries) do\n"
"                if not (entry.requested_subtitles == nil) then\n"
"                    entry_wsubs = i\n"
"                    break\n"
"                end\n"
"            end\n"
"\n"
"            if not (entry_wsubs == nil) and\n"
"                not (json.entries[entry_wsubs].duration == nil) then\n"
"                for j, req in pairs(json.entries[entry_wsubs].requested_subtitles) do\n"
"                    local subfile = \"edl://\"\n"
"                    for i, entry in pairs(json.entries) do\n"
"                        if not (entry.requested_subtitles == nil) and\n"
"                            not (entry.requested_subtitles[j] == nil) and\n"
"                            url_is_safe(entry.requested_subtitles[j].url) then\n"
"                            subfile = subfile..edl_escape(entry.requested_subtitles[j].url)\n"
"                        else\n"
"                            subfile = subfile..edl_escape(\"memory://WEBVTT\")\n"
"                        end\n"
"                        subfile = subfile..\",length=\"..entry.duration..\";\"\n"
"                    end\n"
"                    msg.debug(j..\" sub EDL: \"..subfile)\n"
"                    mp.commandv(\"sub-add\", subfile, \"auto\", req.ext, j)\n"
"                end\n"
"            end\n"
"\n"
"        elseif self_redirecting_url and #json.entries == 1 then\n"
"            msg.verbose(\"Playlist with single entry detected.\")\n"
"            add_single_video(json.entries[1])\n"
"        else\n"
"            local playlist_index = parse_yt_playlist(url, json)\n"
"            local playlist = {\"#EXTM3U\"}\n"
"            for i, entry in pairs(json.entries) do\n"
"                local site = entry.url\n"
"                local title = entry.title\n"
"\n"
"                if not (title == nil) then\n"
"                    title = string.gsub(title, '%s+', ' ')\n"
"                    table.insert(playlist, \"#EXTINF:0,\" .. title)\n"
"                end\n"
"\n"
"                --[[ some extractors will still return the full info for\n"
"                     all clips in the playlist and the URL will point\n"
"                     directly to the file in that case, which we don't\n"
"                     want so get the webpage URL instead, which is what\n"
"                     we want, but only if we aren't going to trigger an\n"
"                     infinite loop\n"
"                --]]\n"
"                if entry[\"webpage_url\"] and not self_redirecting_url then\n"
"                    site = entry[\"webpage_url\"]\n"
"                end\n"
"\n"
"                -- links without protocol as returned by --flat-playlist\n"
"                if not site:find(\"://\") then\n"
"                    -- youtube extractor provides only IDs,\n"
"                    -- others come prefixed with the extractor name and \":\"\n"
"                    local prefix = site:find(\":\") and \"ytdl://\" or\n"
"                        \"https://youtu.be/\"\n"
"                    table.insert(playlist, prefix .. site)\n"
"                elseif url_is_safe(site) then\n"
"                    table.insert(playlist, site)\n"
"                end\n"
"\n"
"            end\n"
"\n"
"            if use_playlist and\n"
"                not option_was_set(\"playlist-start\") and playlist_index then\n"
"                mp.set_property_number(\"playlist-start\", playlist_index)\n"
"            end\n"
"\n"
"            mp.set_property(\"stream-open-filename\", \"memory://\" .. table.concat(playlist, \"\\n\"))\n"
"        end\n"
"\n"
"    else -- probably a video\n"
"        add_single_video(json)\n"
"    end\n"
"    msg.debug('script running time: '..os.clock()-start_time..' seconds')\n"
"end\n"
"\n"
"if (not o.try_ytdl_first) then\n"
"    mp.add_hook(\"on_load\", 10, function ()\n"
"        msg.verbose('ytdl:// hook')\n"
"        local url = mp.get_property(\"stream-open-filename\", \"\")\n"
"        if not (url:find(\"ytdl://\") == 1) then\n"
"            msg.verbose('not a ytdl:// url')\n"
"            return\n"
"        end\n"
"        run_ytdl_hook(url)\n"
"    end)\n"
"end\n"
"\n"
"mp.add_hook(o.try_ytdl_first and \"on_load\" or \"on_load_fail\", 10, function()\n"
"    msg.verbose('full hook')\n"
"    local url = mp.get_property(\"stream-open-filename\", \"\")\n"
"    if not (url:find(\"ytdl://\") == 1) and\n"
"        not ((url:find(\"https\077://\") == 1) and not is_blacklisted(url)) then\n"
"        return\n"
"    end\n"
"    run_ytdl_hook(url)\n"
"end)\n"
"\n"
"mp.add_hook(\"on_preloaded\", 10, function ()\n"
"    if next(chapter_list) ~= nil then\n"
"        msg.verbose(\"Setting chapters\")\n"
"\n"
"        mp.set_property_native(\"chapter-list\", chapter_list)\n"
"        chapter_list = {}\n"
"    end\n"
"end)\n"
